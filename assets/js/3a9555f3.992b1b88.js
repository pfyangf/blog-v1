"use strict";(globalThis.webpackChunkblog_v1=globalThis.webpackChunkblog_v1||[]).push([[4726],{3731(n,e,t){t.r(e),t.d(e,{assets:()=>c,contentTitle:()=>o,default:()=>u,frontMatter:()=>i,metadata:()=>r,toc:()=>l});var r=t(963),a=t(4848),s=t(8453);const i={slug:"solidity-security-patterns",title:"Solidity Security Patterns: Writing Secure Smart Contracts",authors:["autosec"],tags:["Solidity","smart contract security","security patterns","best practices","Web3"]},o="Solidity Security Patterns: Writing Secure Smart Contracts",c={authorsImageUrls:[void 0]},l=[{value:"Fundamental Security Patterns",id:"fundamental-security-patterns",level:2},{value:"1. Checks-Effects-Interactions Pattern",id:"1-checks-effects-interactions-pattern",level:3},{value:"2. Pull Over Push Pattern",id:"2-pull-over-push-pattern",level:3},{value:"3. Rate Limiting",id:"3-rate-limiting",level:3},{value:"Access Control Patterns",id:"access-control-patterns",level:2},{value:"1. Role-Based Access Control (RBAC)",id:"1-role-based-access-control-rbac",level:3},{value:"2. Multi-Signature Pattern",id:"2-multi-signature-pattern",level:3},{value:"State Machine Pattern",id:"state-machine-pattern",level:2},{value:"Emergency Stop Pattern",id:"emergency-stop-pattern",level:2},{value:"Secure Randomness Pattern",id:"secure-randomness-pattern",level:2},{value:"Upgrade Patterns",id:"upgrade-patterns",level:2},{value:"Transparent Proxy Pattern",id:"transparent-proxy-pattern",level:3},{value:"Gas Optimization Patterns",id:"gas-optimization-patterns",level:2},{value:"1. Packing Storage Variables",id:"1-packing-storage-variables",level:3},{value:"2. Using Events for Data Storage",id:"2-using-events-for-data-storage",level:3},{value:"Testing Patterns",id:"testing-patterns",level:2},{value:"Conclusion",id:"conclusion",level:2}];function d(n){const e={code:"code",h2:"h2",h3:"h3",hr:"hr",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...n.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(e.p,{children:"Writing secure smart contracts requires more than just knowing Solidity syntax. It demands understanding common vulnerabilities and applying proven security patterns. This guide covers essential patterns every Solidity developer should know."}),"\n",(0,a.jsx)(e.h2,{id:"fundamental-security-patterns",children:"Fundamental Security Patterns"}),"\n",(0,a.jsx)(e.h3,{id:"1-checks-effects-interactions-pattern",children:"1. Checks-Effects-Interactions Pattern"}),"\n",(0,a.jsx)(e.p,{children:"The most important pattern for preventing reentrancy attacks."}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-solidity",children:'contract SecureWithdrawal {\n    mapping(address => uint256) public balances;\n    \n    function withdraw(uint256 amount) external {\n        // CHECKS: Validate conditions\n        require(balances[msg.sender] >= amount, "Insufficient balance");\n        require(amount > 0, "Amount must be positive");\n        \n        // EFFECTS: Update state\n        balances[msg.sender] -= amount;\n        \n        // INTERACTIONS: External calls\n        (bool success, ) = msg.sender.call{value: amount}("");\n        require(success, "Transfer failed");\n    }\n}\n'})}),"\n",(0,a.jsx)(e.h3,{id:"2-pull-over-push-pattern",children:"2. Pull Over Push Pattern"}),"\n",(0,a.jsx)(e.p,{children:"Instead of pushing payments, let users pull them."}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-solidity",children:'contract PullPayment {\n    mapping(address => uint256) public pendingWithdrawals;\n    \n    function allowWithdrawal(address payee, uint256 amount) internal {\n        pendingWithdrawals[payee] += amount;\n    }\n    \n    function withdraw() external {\n        uint256 amount = pendingWithdrawals[msg.sender];\n        require(amount > 0, "No funds to withdraw");\n        \n        pendingWithdrawals[msg.sender] = 0;\n        \n        (bool success, ) = msg.sender.call{value: amount}("");\n        require(success, "Transfer failed");\n    }\n}\n'})}),"\n",(0,a.jsx)(e.h3,{id:"3-rate-limiting",children:"3. Rate Limiting"}),"\n",(0,a.jsx)(e.p,{children:"Protect against spam and abuse."}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-solidity",children:'contract RateLimited {\n    mapping(address => uint256) public lastActionTime;\n    mapping(address => uint256) public actionCount;\n    \n    uint256 public constant COOLDOWN_PERIOD = 1 hours;\n    uint256 public constant MAX_ACTIONS_PER_PERIOD = 10;\n    \n    modifier rateLimit() {\n        if (block.timestamp > lastActionTime[msg.sender] + COOLDOWN_PERIOD) {\n            actionCount[msg.sender] = 0;\n            lastActionTime[msg.sender] = block.timestamp;\n        }\n        \n        require(\n            actionCount[msg.sender] < MAX_ACTIONS_PER_PERIOD,\n            "Rate limit exceeded"\n        );\n        \n        actionCount[msg.sender]++;\n        _;\n    }\n    \n    function performAction() external rateLimit {\n        // Action logic\n    }\n}\n'})}),"\n",(0,a.jsx)(e.h2,{id:"access-control-patterns",children:"Access Control Patterns"}),"\n",(0,a.jsx)(e.h3,{id:"1-role-based-access-control-rbac",children:"1. Role-Based Access Control (RBAC)"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-solidity",children:'import "@openzeppelin/contracts/access/AccessControl.sol";\n\ncontract RBACExample is AccessControl {\n    bytes32 public constant ADMIN_ROLE = keccak256("ADMIN_ROLE");\n    bytes32 public constant MINTER_ROLE = keccak256("MINTER_ROLE");\n    bytes32 public constant BURNER_ROLE = keccak256("BURNER_ROLE");\n    \n    constructor() {\n        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);\n        _setupRole(ADMIN_ROLE, msg.sender);\n    }\n    \n    function mint(address to, uint256 amount) external onlyRole(MINTER_ROLE) {\n        // Mint logic\n    }\n    \n    function burn(address from, uint256 amount) external onlyRole(BURNER_ROLE) {\n        // Burn logic\n    }\n    \n    function grantMinterRole(address account) external onlyRole(ADMIN_ROLE) {\n        grantRole(MINTER_ROLE, account);\n    }\n}\n'})}),"\n",(0,a.jsx)(e.h3,{id:"2-multi-signature-pattern",children:"2. Multi-Signature Pattern"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-solidity",children:'contract MultiSig {\n    address[] public owners;\n    mapping(address => bool) public isOwner;\n    uint256 public required;\n    \n    struct Transaction {\n        address to;\n        uint256 value;\n        bytes data;\n        bool executed;\n        uint256 confirmations;\n    }\n    \n    Transaction[] public transactions;\n    mapping(uint256 => mapping(address => bool)) public confirmations;\n    \n    modifier onlyOwner() {\n        require(isOwner[msg.sender], "Not owner");\n        _;\n    }\n    \n    modifier txExists(uint256 txId) {\n        require(txId < transactions.length, "Transaction does not exist");\n        _;\n    }\n    \n    modifier notExecuted(uint256 txId) {\n        require(!transactions[txId].executed, "Transaction already executed");\n        _;\n    }\n    \n    constructor(address[] memory _owners, uint256 _required) {\n        require(_owners.length > 0, "Owners required");\n        require(\n            _required > 0 && _required <= _owners.length,\n            "Invalid required number"\n        );\n        \n        for (uint256 i = 0; i < _owners.length; i++) {\n            address owner = _owners[i];\n            require(owner != address(0), "Invalid owner");\n            require(!isOwner[owner], "Owner not unique");\n            \n            isOwner[owner] = true;\n            owners.push(owner);\n        }\n        \n        required = _required;\n    }\n    \n    function submitTransaction(\n        address to,\n        uint256 value,\n        bytes memory data\n    ) external onlyOwner returns (uint256) {\n        uint256 txId = transactions.length;\n        \n        transactions.push(Transaction({\n            to: to,\n            value: value,\n            data: data,\n            executed: false,\n            confirmations: 0\n        }));\n        \n        return txId;\n    }\n    \n    function confirmTransaction(uint256 txId)\n        external\n        onlyOwner\n        txExists(txId)\n        notExecuted(txId)\n    {\n        require(!confirmations[txId][msg.sender], "Transaction already confirmed");\n        \n        confirmations[txId][msg.sender] = true;\n        transactions[txId].confirmations++;\n        \n        if (transactions[txId].confirmations >= required) {\n            executeTransaction(txId);\n        }\n    }\n    \n    function executeTransaction(uint256 txId) internal {\n        Transaction storage transaction = transactions[txId];\n        transaction.executed = true;\n        \n        (bool success, ) = transaction.to.call{value: transaction.value}(\n            transaction.data\n        );\n        require(success, "Transaction execution failed");\n    }\n}\n'})}),"\n",(0,a.jsx)(e.h2,{id:"state-machine-pattern",children:"State Machine Pattern"}),"\n",(0,a.jsx)(e.p,{children:"Enforce valid state transitions."}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-solidity",children:'contract Crowdfunding {\n    enum State { Fundraising, Expired, Successful }\n    \n    State public state = State.Fundraising;\n    uint256 public deadline;\n    uint256 public goal;\n    uint256 public totalRaised;\n    \n    modifier inState(State _state) {\n        require(state == _state, "Invalid state");\n        _;\n    }\n    \n    modifier checkDeadline() {\n        if (block.timestamp > deadline && state == State.Fundraising) {\n            state = totalRaised >= goal ? State.Successful : State.Expired;\n        }\n        _;\n    }\n    \n    function contribute() external payable inState(State.Fundraising) checkDeadline {\n        require(msg.value > 0, "Contribution must be positive");\n        \n        totalRaised += msg.value;\n        \n        if (totalRaised >= goal) {\n            state = State.Successful;\n        }\n    }\n    \n    function withdraw() external inState(State.Successful) {\n        // Withdrawal logic\n    }\n    \n    function refund() external inState(State.Expired) {\n        // Refund logic\n    }\n}\n'})}),"\n",(0,a.jsx)(e.h2,{id:"emergency-stop-pattern",children:"Emergency Stop Pattern"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-solidity",children:'contract EmergencyStop {\n    address public owner;\n    bool public stopped;\n    \n    modifier onlyOwner() {\n        require(msg.sender == owner, "Not owner");\n        _;\n    }\n    \n    modifier stopInEmergency() {\n        require(!stopped, "Contract is stopped");\n        _;\n    }\n    \n    modifier onlyInEmergency() {\n        require(stopped, "Not in emergency");\n        _;\n    }\n    \n    function toggleContractActive() external onlyOwner {\n        stopped = !stopped;\n    }\n    \n    function deposit() external payable stopInEmergency {\n        // Normal operation\n    }\n    \n    function emergencyWithdraw() external onlyInEmergency {\n        // Emergency operation\n    }\n}\n'})}),"\n",(0,a.jsx)(e.h2,{id:"secure-randomness-pattern",children:"Secure Randomness Pattern"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-solidity",children:'import "@chainlink/contracts/src/v0.8/VRFConsumerBase.sol";\n\ncontract SecureRandom is VRFConsumerBase {\n    bytes32 internal keyHash;\n    uint256 internal fee;\n    uint256 public randomResult;\n    \n    mapping(bytes32 => address) public requestToSender;\n    \n    event RandomnessRequested(bytes32 requestId);\n    event RandomnessFulfilled(bytes32 requestId, uint256 randomness);\n    \n    constructor(\n        address _vrfCoordinator,\n        address _link,\n        bytes32 _keyHash,\n        uint256 _fee\n    ) VRFConsumerBase(_vrfCoordinator, _link) {\n        keyHash = _keyHash;\n        fee = _fee;\n    }\n    \n    function getRandomNumber() external returns (bytes32 requestId) {\n        require(LINK.balanceOf(address(this)) >= fee, "Not enough LINK");\n        \n        requestId = requestRandomness(keyHash, fee);\n        requestToSender[requestId] = msg.sender;\n        \n        emit RandomnessRequested(requestId);\n        return requestId;\n    }\n    \n    function fulfillRandomness(bytes32 requestId, uint256 randomness)\n        internal\n        override\n    {\n        randomResult = randomness;\n        emit RandomnessFulfilled(requestId, randomness);\n    }\n}\n'})}),"\n",(0,a.jsx)(e.h2,{id:"upgrade-patterns",children:"Upgrade Patterns"}),"\n",(0,a.jsx)(e.h3,{id:"transparent-proxy-pattern",children:"Transparent Proxy Pattern"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-solidity",children:'contract TransparentProxy {\n    address public implementation;\n    address public admin;\n    \n    modifier onlyAdmin() {\n        require(msg.sender == admin, "Not admin");\n        _;\n    }\n    \n    constructor(address _implementation) {\n        implementation = _implementation;\n        admin = msg.sender;\n    }\n    \n    function upgradeTo(address newImplementation) external onlyAdmin {\n        require(newImplementation != address(0), "Invalid address");\n        implementation = newImplementation;\n    }\n    \n    fallback() external payable {\n        address impl = implementation;\n        \n        assembly {\n            calldatacopy(0, 0, calldatasize())\n            let result := delegatecall(gas(), impl, 0, calldatasize(), 0, 0)\n            returndatacopy(0, 0, returndatasize())\n            \n            switch result\n            case 0 { revert(0, returndatasize()) }\n            default { return(0, returndatasize()) }\n        }\n    }\n}\n'})}),"\n",(0,a.jsx)(e.h2,{id:"gas-optimization-patterns",children:"Gas Optimization Patterns"}),"\n",(0,a.jsx)(e.h3,{id:"1-packing-storage-variables",children:"1. Packing Storage Variables"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-solidity",children:"contract GasOptimized {\n    // Bad: Uses 3 storage slots\n    uint256 a;  // slot 0\n    uint128 b;  // slot 1\n    uint128 c;  // slot 2\n    \n    // Good: Uses 2 storage slots\n    uint256 x;      // slot 0\n    uint128 y;      // slot 1\n    uint128 z;      // slot 1 (packed with y)\n}\n"})}),"\n",(0,a.jsx)(e.h3,{id:"2-using-events-for-data-storage",children:"2. Using Events for Data Storage"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-solidity",children:"contract EventStorage {\n    event DataStored(uint256 indexed id, bytes data);\n    \n    // Instead of storing in state (expensive)\n    // mapping(uint256 => bytes) public data;\n    \n    // Emit events (cheaper)\n    function storeData(uint256 id, bytes memory data) external {\n        emit DataStored(id, data);\n    }\n}\n"})}),"\n",(0,a.jsx)(e.h2,{id:"testing-patterns",children:"Testing Patterns"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-javascript",children:'const { expect } = require("chai");\nconst { ethers } = require("hardhat");\n\ndescribe("Security Patterns", function() {\n    let contract;\n    let owner, user1, user2;\n    \n    beforeEach(async function() {\n        [owner, user1, user2] = await ethers.getSigners();\n        \n        const Contract = await ethers.getContractFactory("SecureContract");\n        contract = await Contract.deploy();\n        await contract.deployed();\n    });\n    \n    describe("Access Control", function() {\n        it("Should only allow owner to perform admin actions", async function() {\n            await expect(\n                contract.connect(user1).adminFunction()\n            ).to.be.revertedWith("Not owner");\n        });\n    });\n    \n    describe("Reentrancy Protection", function() {\n        it("Should prevent reentrancy attacks", async function() {\n            const Attacker = await ethers.getContractFactory("ReentrancyAttacker");\n            const attacker = await Attacker.deploy(contract.address);\n            \n            await expect(\n                attacker.attack({ value: ethers.utils.parseEther("1") })\n            ).to.be.reverted;\n        });\n    });\n    \n    describe("Rate Limiting", function() {\n        it("Should enforce rate limits", async function() {\n            for (let i = 0; i < 10; i++) {\n                await contract.performAction();\n            }\n            \n            await expect(\n                contract.performAction()\n            ).to.be.revertedWith("Rate limit exceeded");\n        });\n    });\n});\n'})}),"\n",(0,a.jsx)(e.h2,{id:"conclusion",children:"Conclusion"}),"\n",(0,a.jsx)(e.p,{children:"Secure smart contract development requires:"}),"\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsxs)(e.li,{children:["\ud83d\udd12 ",(0,a.jsx)(e.strong,{children:"Consistent application of security patterns"})]}),"\n",(0,a.jsxs)(e.li,{children:["\ud83e\uddea ",(0,a.jsx)(e.strong,{children:"Comprehensive testing"})]}),"\n",(0,a.jsxs)(e.li,{children:["\ud83d\udcca ",(0,a.jsx)(e.strong,{children:"Regular audits"})]}),"\n",(0,a.jsxs)(e.li,{children:["\ud83d\udd04 ",(0,a.jsx)(e.strong,{children:"Continuous learning"})]}),"\n"]}),"\n",(0,a.jsxs)(e.p,{children:["Remember: ",(0,a.jsx)(e.strong,{children:"Security is not a feature, it's a requirement."})]}),"\n",(0,a.jsx)(e.hr,{}),"\n",(0,a.jsxs)(e.p,{children:[(0,a.jsx)(e.strong,{children:"AutoSec"})," - Building secure Web3 applications through proven patterns and best practices."]})]})}function u(n={}){const{wrapper:e}={...(0,s.R)(),...n.components};return e?(0,a.jsx)(e,{...n,children:(0,a.jsx)(d,{...n})}):d(n)}},8453(n,e,t){t.d(e,{R:()=>i,x:()=>o});var r=t(6540);const a={},s=r.createContext(a);function i(n){const e=r.useContext(s);return r.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function o(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(a):n.components||a:i(n.components),r.createElement(s.Provider,{value:e},n.children)}},963(n){n.exports=JSON.parse('{"permalink":"/solidity-security-patterns","editUrl":"https://github.com/pfyangf/pfyangf.github.io/tree/main/blog/2025/02-01-solidity-security-patterns.md","source":"@site/blog/2025/02-01-solidity-security-patterns.md","title":"Solidity Security Patterns: Writing Secure Smart Contracts","description":"Writing secure smart contracts requires more than just knowing Solidity syntax. It demands understanding common vulnerabilities and applying proven security patterns. This guide covers essential patterns every Solidity developer should know.","date":"2025-02-01T00:00:00.000Z","tags":[{"inline":true,"label":"Solidity","permalink":"/tags/solidity"},{"inline":true,"label":"smart contract security","permalink":"/tags/smart-contract-security"},{"inline":true,"label":"security patterns","permalink":"/tags/security-patterns"},{"inline":true,"label":"best practices","permalink":"/tags/best-practices"},{"inline":true,"label":"Web3","permalink":"/tags/web-3"}],"readingTime":5.2,"hasTruncateMarker":true,"authors":[{"name":"AutoSec Team","title":"Web3 Security Researchers","url":"https://autosec.dev","imageURL":"/img/autosec.logo.png","key":"autosec","page":null}],"frontMatter":{"slug":"solidity-security-patterns","title":"Solidity Security Patterns: Writing Secure Smart Contracts","authors":["autosec"],"tags":["Solidity","smart contract security","security patterns","best practices","Web3"]},"unlisted":false,"prevItem":{"title":"React Hooks \u5b8c\u5168\u6307\u5357","permalink":"/react-hooks-guide"},"nextItem":{"title":"Web3\u94b1\u5305\u5b89\u5168\u5b8c\u5168\u6307\u5357\uff1a\u4ece\u539f\u7406\u5230\u5b9e\u8df5","permalink":"/web3-wallet-security"}}')}}]);