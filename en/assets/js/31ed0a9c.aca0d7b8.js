"use strict";(globalThis.webpackChunkblog_v1=globalThis.webpackChunkblog_v1||[]).push([[645],{8476(e,n,i){i.r(n),i.d(n,{assets:()=>l,contentTitle:()=>c,default:()=>u,frontMatter:()=>a,metadata:()=>t,toc:()=>o});var t=i(1436),r=i(4848),s=i(8453);const a={slug:"cross-chain-bridge-security",title:"Cross-Chain Bridge Security: Vulnerabilities and Best Practices",authors:["autosec"],tags:["cross-chain","bridge security","blockchain","Web3 security","vulnerability analysis"]},c="Cross-Chain Bridge Security: Vulnerabilities and Best Practices",l={authorsImageUrls:[void 0]},o=[{value:"Understanding Cross-Chain Bridges",id:"understanding-cross-chain-bridges",level:2},{value:"What Are Cross-Chain Bridges?",id:"what-are-cross-chain-bridges",level:3},{value:"Common Bridge Architectures",id:"common-bridge-architectures",level:3},{value:"1. Lock and Mint",id:"1-lock-and-mint",level:4},{value:"2. Liquidity Pools",id:"2-liquidity-pools",level:4},{value:"Major Bridge Hacks",id:"major-bridge-hacks",level:2},{value:"Ronin Bridge Hack (March 2022)",id:"ronin-bridge-hack-march-2022",level:3},{value:"Wormhole Bridge Hack (February 2022)",id:"wormhole-bridge-hack-february-2022",level:3},{value:"Poly Network Hack (August 2021)",id:"poly-network-hack-august-2021",level:3},{value:"Common Vulnerabilities",id:"common-vulnerabilities",level:2},{value:"1. Signature Verification Issues",id:"1-signature-verification-issues",level:3},{value:"2. Replay Attacks",id:"2-replay-attacks",level:3},{value:"3. Validator Centralization",id:"3-validator-centralization",level:3},{value:"Security Best Practices",id:"security-best-practices",level:2},{value:"1. Multi-Layer Security",id:"1-multi-layer-security",level:3},{value:"2. Comprehensive Monitoring",id:"2-comprehensive-monitoring",level:3},{value:"3. Emergency Pause Mechanism",id:"3-emergency-pause-mechanism",level:3},{value:"Testing and Auditing",id:"testing-and-auditing",level:2},{value:"Essential Test Cases",id:"essential-test-cases",level:3},{value:"Conclusion",id:"conclusion",level:2}];function d(e){const n={code:"code",h2:"h2",h3:"h3",h4:"h4",hr:"hr",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.p,{children:"Cross-chain bridges have become critical infrastructure in the Web3 ecosystem, enabling asset transfers between different blockchains. However, they've also become prime targets for attackers, with over $2 billion stolen in bridge hacks during 2022 alone."}),"\n",(0,r.jsx)(n.h2,{id:"understanding-cross-chain-bridges",children:"Understanding Cross-Chain Bridges"}),"\n",(0,r.jsx)(n.h3,{id:"what-are-cross-chain-bridges",children:"What Are Cross-Chain Bridges?"}),"\n",(0,r.jsx)(n.p,{children:"Cross-chain bridges are protocols that enable the transfer of assets and data between different blockchain networks. They solve the interoperability problem but introduce new security challenges."}),"\n",(0,r.jsx)(n.h3,{id:"common-bridge-architectures",children:"Common Bridge Architectures"}),"\n",(0,r.jsx)(n.h4,{id:"1-lock-and-mint",children:"1. Lock and Mint"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-solidity",children:'// Simplified Lock and Mint Bridge\ncontract LockAndMintBridge {\n    mapping(bytes32 => bool) public processedTransactions;\n    \n    event TokensLocked(\n        address indexed user,\n        uint256 amount,\n        uint256 targetChain,\n        bytes32 txHash\n    );\n    \n    event TokensMinted(\n        address indexed user,\n        uint256 amount,\n        bytes32 sourceTxHash\n    );\n    \n    // Lock tokens on source chain\n    function lockTokens(\n        uint256 amount,\n        uint256 targetChain\n    ) external {\n        require(amount > 0, "Amount must be positive");\n        \n        // Transfer tokens to bridge contract\n        token.transferFrom(msg.sender, address(this), amount);\n        \n        bytes32 txHash = keccak256(\n            abi.encodePacked(\n                msg.sender,\n                amount,\n                targetChain,\n                block.timestamp\n            )\n        );\n        \n        emit TokensLocked(msg.sender, amount, targetChain, txHash);\n    }\n    \n    // Mint wrapped tokens on target chain\n    function mintTokens(\n        address user,\n        uint256 amount,\n        bytes32 sourceTxHash,\n        bytes[] memory signatures\n    ) external {\n        require(!processedTransactions[sourceTxHash], "Already processed");\n        require(verifySignatures(signatures, sourceTxHash), "Invalid signatures");\n        \n        processedTransactions[sourceTxHash] = true;\n        wrappedToken.mint(user, amount);\n        \n        emit TokensMinted(user, amount, sourceTxHash);\n    }\n}\n'})}),"\n",(0,r.jsx)(n.h4,{id:"2-liquidity-pools",children:"2. Liquidity Pools"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-solidity",children:'contract LiquidityPoolBridge {\n    mapping(address => uint256) public liquidity;\n    \n    function addLiquidity(uint256 amount) external {\n        token.transferFrom(msg.sender, address(this), amount);\n        liquidity[msg.sender] += amount;\n    }\n    \n    function swap(\n        uint256 amount,\n        uint256 targetChain\n    ) external {\n        require(\n            token.balanceOf(address(this)) >= amount,\n            "Insufficient liquidity"\n        );\n        \n        token.transferFrom(msg.sender, address(this), amount);\n        \n        // Emit event for relayers to process on target chain\n        emit SwapInitiated(msg.sender, amount, targetChain);\n    }\n}\n'})}),"\n",(0,r.jsx)(n.h2,{id:"major-bridge-hacks",children:"Major Bridge Hacks"}),"\n",(0,r.jsx)(n.h3,{id:"ronin-bridge-hack-march-2022",children:"Ronin Bridge Hack (March 2022)"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Loss"}),": $625 million"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Attack Vector"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Compromised 5 out of 9 validator private keys"}),"\n",(0,r.jsx)(n.li,{children:"Attacker gained control of the multi-sig wallet"}),"\n",(0,r.jsx)(n.li,{children:"Withdrew 173,600 ETH and 25.5M USDC"}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Root Cause"}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-solidity",children:"// Vulnerable multi-sig configuration\ncontract VulnerableMultiSig {\n    uint256 public constant REQUIRED_SIGNATURES = 5;\n    uint256 public constant TOTAL_VALIDATORS = 9;\n    \n    // Problem: Too few validators controlled by same entity\n    // 4 validators controlled by Sky Mavis\n    // 1 validator was Axie DAO (compromised via social engineering)\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"wormhole-bridge-hack-february-2022",children:"Wormhole Bridge Hack (February 2022)"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Loss"}),": $325 million"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Attack Vector"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Exploited signature verification vulnerability"}),"\n",(0,r.jsx)(n.li,{children:"Forged guardian signatures"}),"\n",(0,r.jsx)(n.li,{children:"Minted 120,000 wrapped ETH without locking real ETH"}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Vulnerable Code Pattern"}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-solidity",children:"// Simplified vulnerable signature verification\nfunction verifySignatures(\n    bytes32 hash,\n    bytes[] memory signatures\n) internal view returns (bool) {\n    uint256 validSignatures = 0;\n    \n    for (uint256 i = 0; i < signatures.length; i++) {\n        address signer = recoverSigner(hash, signatures[i]);\n        \n        // Vulnerability: No check for duplicate signers\n        if (isGuardian(signer)) {\n            validSignatures++;\n        }\n    }\n    \n    return validSignatures >= REQUIRED_SIGNATURES;\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"poly-network-hack-august-2021",children:"Poly Network Hack (August 2021)"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Loss"}),": $611 million (later returned)"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Attack Vector"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Exploited privilege escalation vulnerability"}),"\n",(0,r.jsxs)(n.li,{children:["Called privileged function ",(0,r.jsx)(n.code,{children:"EthCrossChainManager"})]}),"\n",(0,r.jsx)(n.li,{children:"Modified keeper addresses to attacker's address"}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"common-vulnerabilities",children:"Common Vulnerabilities"}),"\n",(0,r.jsx)(n.h3,{id:"1-signature-verification-issues",children:"1. Signature Verification Issues"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-solidity",children:'// Secure signature verification\ncontract SecureSignatureVerification {\n    mapping(address => bool) public usedSigners;\n    \n    function verifySignatures(\n        bytes32 hash,\n        bytes[] memory signatures\n    ) internal returns (bool) {\n        require(signatures.length >= REQUIRED_SIGNATURES, "Not enough signatures");\n        \n        uint256 validSignatures = 0;\n        \n        for (uint256 i = 0; i < signatures.length; i++) {\n            address signer = recoverSigner(hash, signatures[i]);\n            \n            // Check for duplicates\n            require(!usedSigners[signer], "Duplicate signer");\n            \n            if (isGuardian(signer)) {\n                usedSigners[signer] = true;\n                validSignatures++;\n            }\n        }\n        \n        // Clean up\n        for (uint256 i = 0; i < signatures.length; i++) {\n            address signer = recoverSigner(hash, signatures[i]);\n            usedSigners[signer] = false;\n        }\n        \n        return validSignatures >= REQUIRED_SIGNATURES;\n    }\n}\n'})}),"\n",(0,r.jsx)(n.h3,{id:"2-replay-attacks",children:"2. Replay Attacks"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-solidity",children:'contract ReplayProtection {\n    mapping(bytes32 => bool) public processedTransactions;\n    uint256 public nonce;\n    \n    function processTransaction(\n        address user,\n        uint256 amount,\n        uint256 targetNonce,\n        bytes[] memory signatures\n    ) external {\n        require(targetNonce == nonce, "Invalid nonce");\n        \n        bytes32 txHash = keccak256(\n            abi.encodePacked(\n                user,\n                amount,\n                targetNonce,\n                block.chainid // Include chain ID\n            )\n        );\n        \n        require(!processedTransactions[txHash], "Already processed");\n        require(verifySignatures(txHash, signatures), "Invalid signatures");\n        \n        processedTransactions[txHash] = true;\n        nonce++;\n        \n        // Process transaction\n    }\n}\n'})}),"\n",(0,r.jsx)(n.h3,{id:"3-validator-centralization",children:"3. Validator Centralization"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-solidity",children:'// Decentralized validator management\ncontract DecentralizedValidators {\n    struct Validator {\n        address addr;\n        uint256 stake;\n        bool active;\n    }\n    \n    Validator[] public validators;\n    uint256 public constant MIN_STAKE = 100000 * 1e18;\n    uint256 public constant MIN_VALIDATORS = 13;\n    \n    function addValidator(address validator) external {\n        require(validators.length < 100, "Max validators reached");\n        \n        // Require stake\n        token.transferFrom(msg.sender, address(this), MIN_STAKE);\n        \n        validators.push(Validator({\n            addr: validator,\n            stake: MIN_STAKE,\n            active: true\n        }));\n    }\n    \n    function removeValidator(uint256 index) external {\n        require(validators.length > MIN_VALIDATORS, "Min validators required");\n        \n        Validator storage validator = validators[index];\n        require(msg.sender == validator.addr, "Not validator");\n        \n        // Return stake\n        token.transfer(validator.addr, validator.stake);\n        \n        validator.active = false;\n    }\n}\n'})}),"\n",(0,r.jsx)(n.h2,{id:"security-best-practices",children:"Security Best Practices"}),"\n",(0,r.jsx)(n.h3,{id:"1-multi-layer-security",children:"1. Multi-Layer Security"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-solidity",children:'contract SecureBridge {\n    // Layer 1: Multi-sig with sufficient decentralization\n    uint256 public constant REQUIRED_SIGNATURES = 7;\n    uint256 public constant TOTAL_VALIDATORS = 13;\n    \n    // Layer 2: Rate limiting\n    uint256 public constant MAX_DAILY_VOLUME = 10000000 * 1e18;\n    uint256 public dailyVolume;\n    uint256 public lastResetTime;\n    \n    // Layer 3: Time delays for large transactions\n    uint256 public constant LARGE_TX_THRESHOLD = 1000000 * 1e18;\n    uint256 public constant TIME_DELAY = 24 hours;\n    \n    struct PendingTransaction {\n        address user;\n        uint256 amount;\n        uint256 unlockTime;\n        bool executed;\n    }\n    \n    mapping(bytes32 => PendingTransaction) public pendingTransactions;\n    \n    function initiateTransfer(\n        address user,\n        uint256 amount,\n        bytes32 txHash,\n        bytes[] memory signatures\n    ) external {\n        require(verifySignatures(txHash, signatures), "Invalid signatures");\n        \n        // Check rate limit\n        if (block.timestamp > lastResetTime + 1 days) {\n            dailyVolume = 0;\n            lastResetTime = block.timestamp;\n        }\n        \n        require(\n            dailyVolume + amount <= MAX_DAILY_VOLUME,\n            "Daily limit exceeded"\n        );\n        \n        dailyVolume += amount;\n        \n        // Large transactions require time delay\n        if (amount >= LARGE_TX_THRESHOLD) {\n            pendingTransactions[txHash] = PendingTransaction({\n                user: user,\n                amount: amount,\n                unlockTime: block.timestamp + TIME_DELAY,\n                executed: false\n            });\n            \n            emit LargeTransactionPending(txHash, amount, block.timestamp + TIME_DELAY);\n        } else {\n            _executeTransfer(user, amount);\n        }\n    }\n    \n    function executeDelayedTransfer(bytes32 txHash) external {\n        PendingTransaction storage pending = pendingTransactions[txHash];\n        \n        require(!pending.executed, "Already executed");\n        require(block.timestamp >= pending.unlockTime, "Still locked");\n        \n        pending.executed = true;\n        _executeTransfer(pending.user, pending.amount);\n    }\n}\n'})}),"\n",(0,r.jsx)(n.h3,{id:"2-comprehensive-monitoring",children:"2. Comprehensive Monitoring"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-solidity",children:'contract BridgeMonitoring {\n    event AnomalyDetected(string reason, uint256 value, uint256 threshold);\n    \n    uint256 public constant PRICE_DEVIATION_THRESHOLD = 5; // 5%\n    uint256 public constant VOLUME_SPIKE_THRESHOLD = 200; // 200%\n    \n    uint256 public averageDailyVolume;\n    uint256 public lastPrice;\n    \n    function checkAnomalies(uint256 currentVolume, uint256 currentPrice) internal {\n        // Check volume spike\n        if (currentVolume > averageDailyVolume * VOLUME_SPIKE_THRESHOLD / 100) {\n            emit AnomalyDetected("Volume spike", currentVolume, averageDailyVolume);\n            // Trigger alert to monitoring system\n        }\n        \n        // Check price deviation\n        if (lastPrice > 0) {\n            uint256 priceChange = currentPrice > lastPrice\n                ? (currentPrice - lastPrice) * 100 / lastPrice\n                : (lastPrice - currentPrice) * 100 / lastPrice;\n                \n            if (priceChange > PRICE_DEVIATION_THRESHOLD) {\n                emit AnomalyDetected("Price deviation", priceChange, PRICE_DEVIATION_THRESHOLD);\n            }\n        }\n        \n        lastPrice = currentPrice;\n    }\n}\n'})}),"\n",(0,r.jsx)(n.h3,{id:"3-emergency-pause-mechanism",children:"3. Emergency Pause Mechanism"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-solidity",children:'contract EmergencyControls {\n    address public guardian;\n    bool public paused;\n    uint256 public pausedUntil;\n    \n    mapping(address => bool) public emergencyCouncil;\n    uint256 public emergencyVotes;\n    uint256 public constant REQUIRED_EMERGENCY_VOTES = 3;\n    \n    modifier whenNotPaused() {\n        require(!paused || block.timestamp > pausedUntil, "Bridge paused");\n        _;\n    }\n    \n    function emergencyPause() external {\n        require(emergencyCouncil[msg.sender], "Not council member");\n        \n        emergencyVotes++;\n        \n        if (emergencyVotes >= REQUIRED_EMERGENCY_VOTES) {\n            paused = true;\n            pausedUntil = block.timestamp + 7 days;\n            emergencyVotes = 0;\n            \n            emit EmergencyPause(block.timestamp);\n        }\n    }\n    \n    function unpause() external {\n        require(msg.sender == guardian, "Not guardian");\n        paused = false;\n        emit Unpause(block.timestamp);\n    }\n}\n'})}),"\n",(0,r.jsx)(n.h2,{id:"testing-and-auditing",children:"Testing and Auditing"}),"\n",(0,r.jsx)(n.h3,{id:"essential-test-cases",children:"Essential Test Cases"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:'describe("Bridge Security Tests", function() {\n    it("Should prevent signature replay attacks", async function() {\n        const tx = await bridge.processTransaction(user, amount, signatures);\n        \n        // Try to replay the same transaction\n        await expect(\n            bridge.processTransaction(user, amount, signatures)\n        ).to.be.revertedWith("Already processed");\n    });\n    \n    it("Should reject duplicate signers", async function() {\n        const duplicateSignatures = [sig1, sig1, sig2]; // sig1 used twice\n        \n        await expect(\n            bridge.verifySignatures(hash, duplicateSignatures)\n        ).to.be.revertedWith("Duplicate signer");\n    });\n    \n    it("Should enforce rate limits", async function() {\n        // Exceed daily limit\n        await expect(\n            bridge.transfer(DAILY_LIMIT + 1)\n        ).to.be.revertedWith("Daily limit exceeded");\n    });\n    \n    it("Should delay large transactions", async function() {\n        await bridge.initiateTransfer(user, LARGE_AMOUNT, signatures);\n        \n        // Try to execute immediately\n        await expect(\n            bridge.executeDelayedTransfer(txHash)\n        ).to.be.revertedWith("Still locked");\n        \n        // Fast forward time\n        await ethers.provider.send("evm_increaseTime", [24 * 60 * 60]);\n        \n        // Now should succeed\n        await bridge.executeDelayedTransfer(txHash);\n    });\n});\n'})}),"\n",(0,r.jsx)(n.h2,{id:"conclusion",children:"Conclusion"}),"\n",(0,r.jsx)(n.p,{children:"Cross-chain bridge security requires:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\ud83d\udd10 ",(0,r.jsx)(n.strong,{children:"Robust cryptographic verification"})]}),"\n",(0,r.jsxs)(n.li,{children:["\ud83c\udfd7\ufe0f ",(0,r.jsx)(n.strong,{children:"Decentralized validator networks"})]}),"\n",(0,r.jsxs)(n.li,{children:["\u23f1\ufe0f ",(0,r.jsx)(n.strong,{children:"Time delays for large transactions"})]}),"\n",(0,r.jsxs)(n.li,{children:["\ud83d\udcca ",(0,r.jsx)(n.strong,{children:"Comprehensive monitoring systems"})]}),"\n",(0,r.jsxs)(n.li,{children:["\ud83d\udea8 ",(0,r.jsx)(n.strong,{children:"Emergency response mechanisms"})]}),"\n",(0,r.jsxs)(n.li,{children:["\ud83e\uddea ",(0,r.jsx)(n.strong,{children:"Extensive testing and auditing"})]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["Remember: ",(0,r.jsx)(n.strong,{children:"Bridges are high-value targets. Security must be the top priority, not an afterthought."})]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"AutoSec"})," - Protecting the Web3 ecosystem, one bridge at a time."]})]})}function u(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}},8453(e,n,i){i.d(n,{R:()=>a,x:()=>c});var t=i(6540);const r={},s=t.createContext(r);function a(e){const n=t.useContext(s);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:a(e.components),t.createElement(s.Provider,{value:n},e.children)}},1436(e){e.exports=JSON.parse('{"permalink":"/en/cross-chain-bridge-security","editUrl":"https://github.com/pfyangf/pfyangf.github.io/tree/main/blog/2025/02-03-cross-chain-bridge-security.md","source":"@site/blog/2025/02-03-cross-chain-bridge-security.md","title":"Cross-Chain Bridge Security: Vulnerabilities and Best Practices","description":"Cross-chain bridges have become critical infrastructure in the Web3 ecosystem, enabling asset transfers between different blockchains. However, they\'ve also become prime targets for attackers, with over $2 billion stolen in bridge hacks during 2022 alone.","date":"2025-02-03T00:00:00.000Z","tags":[{"inline":true,"label":"cross-chain","permalink":"/en/tags/cross-chain"},{"inline":true,"label":"bridge security","permalink":"/en/tags/bridge-security"},{"inline":true,"label":"blockchain","permalink":"/en/tags/blockchain"},{"inline":true,"label":"Web3 security","permalink":"/en/tags/web-3-security"},{"inline":true,"label":"vulnerability analysis","permalink":"/en/tags/vulnerability-analysis"}],"readingTime":5.82,"hasTruncateMarker":true,"authors":[{"name":"AutoSec Team","title":"Web3 Security Researchers","url":"https://autosec.dev","imageURL":"/en/img/autosec.logo.png","key":"autosec","page":null}],"frontMatter":{"slug":"cross-chain-bridge-security","title":"Cross-Chain Bridge Security: Vulnerabilities and Best Practices","authors":["autosec"],"tags":["cross-chain","bridge security","blockchain","Web3 security","vulnerability analysis"]},"unlisted":false,"prevItem":{"title":"DeFi\u95ea\u7535\u8d37\u653b\u51fb\u6df1\u5ea6\u5256\u6790\uff1a\u539f\u7406\u3001\u6848\u4f8b\u4e0e\u9632\u5fa1","permalink":"/en/defi-flash-loan-attacks"},"nextItem":{"title":"NFT\u667a\u80fd\u5408\u7ea6\u5b89\u5168\u6f0f\u6d1e\u5168\u89e3\u6790","permalink":"/en/nft-security-vulnerabilities"}}')}}]);